;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 49

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING "a"
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_SYMBOL(const_tbl+16)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+32], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+48], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+56], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+64], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+72], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+120], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+136], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+144], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+160], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+168], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+176], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+184], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+192], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+208], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+216], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+224], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+232], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, setcar)
mov [fvar_tbl+240], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, setcdr)
mov [fvar_tbl+248], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.

mov rax, qword [fvar_tbl + 208]
	push rax
mov rax, qword [fvar_tbl + 232]
	push rax
mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 5
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode1)
		jmp Lcont1

	Lcode1:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 
mov rax, const_tbl + 95
	
 push rax 

     push 2
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params2:
                        cmp rbx, r12
                        je end_copy_params2
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params2
                        end_copy_params2:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args2:
                        cmp r14, r13
                        je end_copy_stack_args2
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args2
                        end_copy_stack_args2:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode2)
                        jmp Lcont2
                        
	Lcode2:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	mov rax, qword [rbp + 8 * (4 + 1)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 1)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params3:
                        cmp rbx, r12
                        je end_copy_params3
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params3
                        end_copy_params3:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args3:
                        cmp r14, r13
                        je end_copy_stack_args3
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args3
                        end_copy_stack_args3:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode3)
                        jmp Lcont3
                        
	Lcode3:
	push rbp
	mov rbp, rsp
	

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse4
  mov rax, const_tbl + 1
	jmp Lexit4
	Lelse4:
	


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *4]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit4:
	
	leave
	ret
	Lcont3:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params5:
                        cmp rbx, r12
                        je end_copy_params5
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params5
                        end_copy_params5:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args5:
                        cmp r14, r13
                        je end_copy_stack_args5
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args5
                        end_copy_stack_args5:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode5)
                        jmp Lcont5
                        
	Lcode5:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse6
  mov rax, const_tbl + 1
	jmp Lexit6
	Lelse6:
	


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * (4 + 0)]
	 
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit6:
	
	leave
	ret
	Lcont5:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 1)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params7:
                        cmp rbx, r12
                        je end_copy_params7
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params7
                        end_copy_params7:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args7:
                        cmp r14, r13
                        je end_copy_stack_args7
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args7
                        end_copy_stack_args7:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode7)
                        jmp Lcont7
                        Lcode7:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_7
jl fix_case_2_7


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_7:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop7:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop7
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop7:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop7

fix_rsp7:
cmp r11, 0
je end_fix_rsp7
add rsp, 8
dec r11
jmp fix_rsp7
end_fix_rsp7:
mov qword [rsp + 16], r9
jmp end_fix7

  ;; case 3 :
;; old_n = new_n
	fix_case_3_7:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix7


;; case 2 :
;;if new_n < old_n 

fix_case_2_7:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop7:
	cmp r11, 0
	je end_shift_down_loop7
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop7
	end_shift_down_loop7:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix7:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont7:
	
	leave
	ret
	Lcont2:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont1:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 256], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 272]
	push rax
mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 4
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode8)
		jmp Lcont8

	Lcode8:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params9:
                        cmp rbx, r12
                        je end_copy_params9
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params9
                        end_copy_params9:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args9:
                        cmp r14, r13
                        je end_copy_stack_args9
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args9
                        end_copy_stack_args9:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode9)
                        jmp Lcont9
                        
	Lcode9:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params10:
                        cmp rbx, r12
                        je end_copy_params10
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params10
                        end_copy_params10:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args10:
                        cmp r14, r13
                        je end_copy_stack_args10
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args10
                        end_copy_stack_args10:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode10)
                        jmp Lcont10
                        
	Lcode10:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 2)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse11
  mov rax, qword [rbp + 8 * (4 + 1)]
	 jmp Lexit11
	Lelse11:
	


mov rax, qword [rbp + 8 * (4 + 2)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 3
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 2)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * (4 + 0)]
	 
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit11:
	
	leave
	ret
	Lcont10:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params12:
                        cmp rbx, r12
                        je end_copy_params12
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params12
                        end_copy_params12:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args12:
                        cmp r14, r13
                        je end_copy_stack_args12
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args12
                        end_copy_stack_args12:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode12)
                        jmp Lcont12
                        
	Lcode12:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 2)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont12:
	
	leave
	ret
	Lcont9:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont8:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 264], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 3
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode13)
		jmp Lcont13

	Lcode13:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params14:
                        cmp rbx, r12
                        je end_copy_params14
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params14
                        end_copy_params14:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args14:
                        cmp r14, r13
                        je end_copy_stack_args14
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args14
                        end_copy_stack_args14:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode14)
                        jmp Lcont14
                        
	Lcode14:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params15:
                        cmp rbx, r12
                        je end_copy_params15
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params15
                        end_copy_params15:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args15:
                        cmp r14, r13
                        je end_copy_stack_args15
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args15
                        end_copy_stack_args15:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode15)
                        jmp Lcont15
                        
	Lcode15:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 2)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse16
  mov rax, qword [rbp + 8 * (4 + 1)]
	 jmp Lexit16
	Lelse16:
	

mov rax, qword [rbp + 8 * (4 + 2)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 


mov rax, qword [rbp + 8 * (4 + 2)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * (4 + 0)]
	 
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit16:
	
	leave
	ret
	Lcont15:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params17:
                        cmp rbx, r12
                        je end_copy_params17
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params17
                        end_copy_params17:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args17:
                        cmp r14, r13
                        je end_copy_stack_args17
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args17
                        end_copy_stack_args17:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode17)
                        jmp Lcont17
                        
	Lcode17:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 2)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont17:
	
	leave
	ret
	Lcont14:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont13:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 272], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 232]
	push rax
mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 4
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode18)
		jmp Lcont18

	Lcode18:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params19:
                        cmp rbx, r12
                        je end_copy_params19
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params19
                        end_copy_params19:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args19:
                        cmp r14, r13
                        je end_copy_stack_args19
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args19
                        end_copy_stack_args19:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode19)
                        jmp Lcont19
                        
	Lcode19:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params20:
                        cmp rbx, r12
                        je end_copy_params20
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params20
                        end_copy_params20:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args20:
                        cmp r14, r13
                        je end_copy_stack_args20
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args20
                        end_copy_stack_args20:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode20)
                        jmp Lcont20
                        
	Lcode20:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse22
  mov rax, qword [rbp + 8 * (4 + 0)]
	 jmp Lexit22
	Lelse22:
	

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse21
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit21
	Lelse21:
	


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit21:
	
	Lexit22:
	
	leave
	ret
	Lcont20:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params23:
                        cmp rbx, r12
                        je end_copy_params23
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params23
                        end_copy_params23:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args23:
                        cmp r14, r13
                        je end_copy_stack_args23
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args23
                        end_copy_stack_args23:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode23)
                        jmp Lcont23
                        Lcode23:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_23
jl fix_case_2_23


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_23:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop23:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop23
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop23:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop23

fix_rsp23:
cmp r11, 0
je end_fix_rsp23
add rsp, 8
dec r11
jmp fix_rsp23
end_fix_rsp23:
mov qword [rsp + 16], r9
jmp end_fix23

  ;; case 3 :
;; old_n = new_n
	fix_case_3_23:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix23


;; case 2 :
;;if new_n < old_n 

fix_case_2_23:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop23:
	cmp r11, 0
	je end_shift_down_loop23
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop23
	end_shift_down_loop23:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix23:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont23:
	
	leave
	ret
	Lcont19:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont18:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 280], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 232]
	push rax
mov rax, qword [fvar_tbl + 264]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 3
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode24)
		jmp Lcont24

	Lcode24:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params25:
                        cmp rbx, r12
                        je end_copy_params25
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params25
                        end_copy_params25:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args25:
                        cmp r14, r13
                        je end_copy_stack_args25
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args25
                        end_copy_stack_args25:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode25)
                        jmp Lcont25
                        Lcode25:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 1 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_25
jl fix_case_2_25


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_25:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop25:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop25
mov qword [rsp + 8 * (2 + 1)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop25:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop25

fix_rsp25:
cmp r11, 0
je end_fix_rsp25
add rsp, 8
dec r11
jmp fix_rsp25
end_fix_rsp25:
mov qword [rsp + 16], r9
jmp end_fix25

  ;; case 3 :
;; old_n = new_n
	fix_case_3_25:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix25


;; case 2 :
;;if new_n < old_n 

fix_case_2_25:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop25:
	cmp r11, 0
	je end_shift_down_loop25
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop25
	end_shift_down_loop25:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix25:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, const_tbl + 1
	
 push rax 

                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params26:
                        cmp rbx, r12
                        je end_copy_params26
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params26
                        end_copy_params26:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args26:
                        cmp r14, r13
                        je end_copy_stack_args26
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args26
                        end_copy_stack_args26:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode26)
                        jmp Lcont26
                        
	Lcode26:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse27
  mov rax, qword [rbp + 8 * (4 + 0)]
	 jmp Lexit27
	Lelse27:
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit27:
	
	leave
	ret
	Lcont26:
	
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont25:
	
	leave
	ret
	Lcont24:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 288], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params28:
                        cmp rbx, r12
                        je end_copy_params28
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params28
                        end_copy_params28:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args28:
                        cmp r14, r13
                        je end_copy_stack_args28
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args28
                        end_copy_stack_args28:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode28)
                        jmp Lcont28
                        Lcode28:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 1 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_28
jl fix_case_2_28


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_28:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop28:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop28
mov qword [rsp + 8 * (2 + 1)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop28:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop28

fix_rsp28:
cmp r11, 0
je end_fix_rsp28
add rsp, 8
dec r11
jmp fix_rsp28
end_fix_rsp28:
mov qword [rsp + 16], r9
jmp end_fix28

  ;; case 3 :
;; old_n = new_n
	fix_case_3_28:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix28


;; case 2 :
;;if new_n < old_n 

fix_case_2_28:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop28:
	cmp r11, 0
	je end_shift_down_loop28
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop28
	end_shift_down_loop28:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix28:
	push rbp
	mov rbp, rsp
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	leave
	ret
	Lcont28:
	
	mov qword [fvar_tbl + 296], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 24]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 3
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode29)
		jmp Lcont29

	Lcode29:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params30:
                        cmp rbx, r12
                        je end_copy_params30
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params30
                        end_copy_params30:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args30:
                        cmp r14, r13
                        je end_copy_stack_args30
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args30
                        end_copy_stack_args30:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode30)
                        jmp Lcont30
                        
	Lcode30:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params31:
                        cmp rbx, r12
                        je end_copy_params31
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params31
                        end_copy_params31:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args31:
                        cmp r14, r13
                        je end_copy_stack_args31
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args31
                        end_copy_stack_args31:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode31)
                        jmp Lcont31
                        
	Lcode31:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	 cmp rax, SOB_FALSE_ADDRESS
	 jne Lexit32

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse33
  

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 1
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit33
	Lelse33:
	mov rax, const_tbl + 2
	
	Lexit33:
	
		Lexit32:
		
	leave
	ret
	Lcont31:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	mov rax, qword [rax]
	
	leave
	ret
	Lcont30:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont29:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 304], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void

MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode34)
		jmp Lcont34

	Lcode34:
	push rbp
	mov rbp, rsp
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse35
  mov rax, const_tbl + 2
	jmp Lexit35
	Lelse35:
	mov rax, const_tbl + 4
	
	Lexit35:
	
	leave
	ret
	Lcont34:
	
	mov qword [fvar_tbl + 312], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 32]
	push rax
mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 176]
	push rax
mov rax, qword [fvar_tbl + 168]
	push rax
mov rax, qword [fvar_tbl + 160]
	push rax
mov rax, qword [fvar_tbl + 152]
	push rax
mov rax, qword [fvar_tbl + 144]
	push rax
mov rax, qword [fvar_tbl + 256]
	push rax
mov rax, qword [fvar_tbl + 272]
	push rax
mov rax, qword [fvar_tbl + 128]
	push rax
mov rax, qword [fvar_tbl + 16]
	push rax
mov rax, qword [fvar_tbl + 8]
	push rax

  push 13
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode36)
		jmp Lcont36

	Lcode36:
	push rbp
	mov rbp, rsp
	

                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params37:
                        cmp rbx, r12
                        je end_copy_params37
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params37
                        end_copy_params37:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args37:
                        cmp r14, r13
                        je end_copy_stack_args37
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args37
                        end_copy_stack_args37:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode37)
                        jmp Lcont37
                        
	Lcode37:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params38:
                        cmp rbx, r12
                        je end_copy_params38
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params38
                        end_copy_params38:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args38:
                        cmp r14, r13
                        je end_copy_stack_args38
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args38
                        end_copy_stack_args38:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode38)
                        jmp Lcont38
                        
	Lcode38:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse39
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit39
	Lelse39:
	mov rax, const_tbl + 2
	
	Lexit39:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse42
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit42
	Lelse42:
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse40
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit40
	Lelse40:
	mov rax, const_tbl + 2
	
	Lexit40:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse41
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit41
	Lelse41:
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit41:
	
	Lexit42:
	
	leave
	ret
	Lcont38:
	
	leave
	ret
	Lcont37:
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params43:
                        cmp rbx, r12
                        je end_copy_params43
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params43
                        end_copy_params43:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args43:
                        cmp r14, r13
                        je end_copy_stack_args43
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args43
                        end_copy_stack_args43:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode43)
                        jmp Lcont43
                        
	Lcode43:
	push rbp
	mov rbp, rsp
	

                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params44:
                        cmp rbx, r12
                        je end_copy_params44
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params44
                        end_copy_params44:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args44:
                        cmp r14, r13
                        je end_copy_stack_args44
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args44
                        end_copy_stack_args44:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode44)
                        jmp Lcont44
                        Lcode44:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 1 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_44
jl fix_case_2_44


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_44:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop44:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop44
mov qword [rsp + 8 * (2 + 1)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop44:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop44

fix_rsp44:
cmp r11, 0
je end_fix_rsp44
add rsp, 8
dec r11
jmp fix_rsp44
end_fix_rsp44:
mov qword [rsp + 16], r9
jmp end_fix44

  ;; case 3 :
;; old_n = new_n
	fix_case_3_44:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix44


;; case 2 :
;;if new_n < old_n 

fix_case_2_44:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop44:
	cmp r11, 0
	je end_shift_down_loop44
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop44
	end_shift_down_loop44:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix44:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, const_tbl + 50
	
 push rax 

mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *5]
	push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont44:
	
	mov qword [fvar_tbl + 144], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params45:
                        cmp rbx, r12
                        je end_copy_params45
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params45
                        end_copy_params45:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args45:
                        cmp r14, r13
                        je end_copy_stack_args45
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args45
                        end_copy_stack_args45:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode45)
                        jmp Lcont45
                        Lcode45:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 1 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_45
jl fix_case_2_45


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_45:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop45:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop45
mov qword [rsp + 8 * (2 + 1)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop45:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop45

fix_rsp45:
cmp r11, 0
je end_fix_rsp45
add rsp, 8
dec r11
jmp fix_rsp45
end_fix_rsp45:
mov qword [rsp + 16], r9
jmp end_fix45

  ;; case 3 :
;; old_n = new_n
	fix_case_3_45:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix45


;; case 2 :
;;if new_n < old_n 

fix_case_2_45:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop45:
	cmp r11, 0
	je end_shift_down_loop45
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop45
	end_shift_down_loop45:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix45:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, const_tbl + 67
	
 push rax 

mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *6]
	push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont45:
	
	mov qword [fvar_tbl + 152], rax
	mov rax, SOB_VOID_ADDRESS
	

mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *7]
	push rax

  push 1
  mov rax, qword [rbp + 8 * (4 + 0)]
	 
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params46:
                        cmp rbx, r12
                        je end_copy_params46
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params46
                        end_copy_params46:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args46:
                        cmp r14, r13
                        je end_copy_stack_args46
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args46
                        end_copy_stack_args46:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode46)
                        jmp Lcont46
                        
	Lcode46:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 40
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 4
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params47:
                        cmp rbx, r12
                        je end_copy_params47
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params47
                        end_copy_params47:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args47:
                        cmp r14, r13
                        je end_copy_stack_args47
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args47
                        end_copy_stack_args47:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode47)
                        jmp Lcont47
                        Lcode47:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_47
jl fix_case_2_47


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_47:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop47:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop47
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop47:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop47

fix_rsp47:
cmp r11, 0
je end_fix_rsp47
add rsp, 8
dec r11
jmp fix_rsp47
end_fix_rsp47:
mov qword [rsp + 16], r9
jmp end_fix47

  ;; case 3 :
;; old_n = new_n
	fix_case_3_47:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix47


;; case 2 :
;;if new_n < old_n 

fix_case_2_47:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop47:
	cmp r11, 0
	je end_shift_down_loop47
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop47
	end_shift_down_loop47:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix47:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 2] 
	mov rax, qword [rax + 8 *12]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse48
  
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, const_tbl + 67
	
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit48
	Lelse48:
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 2] 
	mov rax, qword [rax + 8 *3]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit48:
	
	leave
	ret
	Lcont47:
	
	leave
	ret
	Lcont46:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 160], rax
	mov rax, SOB_VOID_ADDRESS
	

                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params49:
                        cmp rbx, r12
                        je end_copy_params49
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params49
                        end_copy_params49:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args49:
                        cmp r14, r13
                        je end_copy_stack_args49
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args49
                        end_copy_stack_args49:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode49)
                        jmp Lcont49
                        
	Lcode49:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params50:
                        cmp rbx, r12
                        je end_copy_params50
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params50
                        end_copy_params50:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args50:
                        cmp r14, r13
                        je end_copy_stack_args50
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args50
                        end_copy_stack_args50:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode50)
                        jmp Lcont50
                        
	Lcode50:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 40
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 4
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params51:
                        cmp rbx, r12
                        je end_copy_params51
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params51
                        end_copy_params51:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args51:
                        cmp r14, r13
                        je end_copy_stack_args51
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args51
                        end_copy_stack_args51:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode51)
                        jmp Lcont51
                        
	Lcode51:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 3] 
	mov rax, qword [rax + 8 *12]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	 cmp rax, SOB_FALSE_ADDRESS
	 jne Lexit52


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 3] 
	mov rax, qword [rax + 8 *10]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse53
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 3] 
	mov rax, qword [rax + 8 *11]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 3] 
	mov rax, qword [rax + 8 *10]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit53
	Lelse53:
	mov rax, const_tbl + 2
	
	Lexit53:
	
		Lexit52:
		
	leave
	ret
	Lcont51:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 48
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 5
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params54:
                        cmp rbx, r12
                        je end_copy_params54
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params54
                        end_copy_params54:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args54:
                        cmp r14, r13
                        je end_copy_stack_args54
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args54
                        end_copy_stack_args54:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode54)
                        jmp Lcont54
                        Lcode54:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_54
jl fix_case_2_54


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_54:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop54:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop54
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop54:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop54

fix_rsp54:
cmp r11, 0
je end_fix_rsp54
add rsp, 8
dec r11
jmp fix_rsp54
end_fix_rsp54:
mov qword [rsp + 16], r9
jmp end_fix54

  ;; case 3 :
;; old_n = new_n
	fix_case_3_54:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix54


;; case 2 :
;;if new_n < old_n 

fix_case_2_54:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop54:
	cmp r11, 0
	je end_shift_down_loop54
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop54
	end_shift_down_loop54:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix54:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont54:
	
	leave
	ret
	Lcont50:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont49:
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params55:
                        cmp rbx, r12
                        je end_copy_params55
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params55
                        end_copy_params55:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args55:
                        cmp r14, r13
                        je end_copy_stack_args55
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args55
                        end_copy_stack_args55:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode55)
                        jmp Lcont55
                        
	Lcode55:
	push rbp
	mov rbp, rsp
	


mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *8]
	push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * (4 + 0)]
	 
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 168], rax
	mov rax, SOB_VOID_ADDRESS
	

mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *9]
	push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * (4 + 0)]
	 
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 176], rax
	mov rax, SOB_VOID_ADDRESS
	
	leave
	ret
	Lcont55:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont43:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont36:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 32]
	push rax
mov rax, qword [fvar_tbl + 144]
	push rax
mov rax, qword [fvar_tbl + 208]
	push rax

  push 3
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode56)
		jmp Lcont56

	Lcode56:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params57:
                        cmp rbx, r12
                        je end_copy_params57
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params57
                        end_copy_params57:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args57:
                        cmp r14, r13
                        je end_copy_stack_args57
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args57
                        end_copy_stack_args57:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode57)
                        jmp Lcont57
                        Lcode57:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_57
jl fix_case_2_57


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_57:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop57:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop57
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop57:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop57

fix_rsp57:
cmp r11, 0
je end_fix_rsp57
add rsp, 8
dec r11
jmp fix_rsp57
end_fix_rsp57:
mov qword [rsp + 16], r9
jmp end_fix57

  ;; case 3 :
;; old_n = new_n
	fix_case_3_57:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix57


;; case 2 :
;;if new_n < old_n 

fix_case_2_57:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop57:
	cmp r11, 0
	je end_shift_down_loop57
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop57
	end_shift_down_loop57:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix57:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse58
  

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax
mov rax, const_tbl + 33
	push rax

  push 2
  mov rax, qword [fvar_tbl + 152]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, const_tbl + 50
	
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit58
	Lelse58:
	


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, const_tbl + 33
	push rax

  push 2
  mov rax, qword [fvar_tbl + 152]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit58:
	
	leave
	ret
	Lcont57:
	
	leave
	ret
	Lcont56:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 320], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 168]
	push rax
mov rax, qword [fvar_tbl + 176]
	push rax
mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 312]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 6
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode59)
		jmp Lcont59

	Lcode59:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params60:
                        cmp rbx, r12
                        je end_copy_params60
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params60
                        end_copy_params60:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args60:
                        cmp r14, r13
                        je end_copy_stack_args60
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args60
                        end_copy_stack_args60:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode60)
                        jmp Lcont60
                        
	Lcode60:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params61:
                        cmp rbx, r12
                        je end_copy_params61
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params61
                        end_copy_params61:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args61:
                        cmp r14, r13
                        je end_copy_stack_args61
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args61
                        end_copy_stack_args61:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode61)
                        jmp Lcont61
                        
	Lcode61:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	 cmp rax, SOB_FALSE_ADDRESS
	 jne Lexit62



mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *4]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse64
  


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *5]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse63
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit63
	Lelse63:
	mov rax, const_tbl + 2
	
	Lexit63:
	jmp Lexit64
	Lelse64:
	mov rax, const_tbl + 2
	
	Lexit64:
	
		Lexit62:
		
	leave
	ret
	Lcont61:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params65:
                        cmp rbx, r12
                        je end_copy_params65
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params65
                        end_copy_params65:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args65:
                        cmp r14, r13
                        je end_copy_stack_args65
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args65
                        end_copy_stack_args65:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode65)
                        jmp Lcont65
                        Lcode65:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_65
jl fix_case_2_65


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_65:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop65:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop65
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop65:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop65

fix_rsp65:
cmp r11, 0
je end_fix_rsp65
add rsp, 8
dec r11
jmp fix_rsp65
end_fix_rsp65:
mov qword [rsp + 16], r9
jmp end_fix65

  ;; case 3 :
;; old_n = new_n
	fix_case_3_65:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix65


;; case 2 :
;;if new_n < old_n 

fix_case_2_65:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop65:
	cmp r11, 0
	je end_shift_down_loop65
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop65
	end_shift_down_loop65:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix65:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont65:
	
	leave
	ret
	Lcont60:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont59:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 328], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax
mov rax, qword [fvar_tbl + 200]
	push rax

  push 4
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode66)
		jmp Lcont66

	Lcode66:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params67:
                        cmp rbx, r12
                        je end_copy_params67
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params67
                        end_copy_params67:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args67:
                        cmp r14, r13
                        je end_copy_stack_args67
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args67
                        end_copy_stack_args67:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode67)
                        jmp Lcont67
                        
	Lcode67:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params68:
                        cmp rbx, r12
                        je end_copy_params68
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params68
                        end_copy_params68:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args68:
                        cmp r14, r13
                        je end_copy_stack_args68
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args68
                        end_copy_stack_args68:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode68)
                        jmp Lcont68
                        
	Lcode68:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse69
  mov rax, qword [rbp + 8 * (4 + 0)]
	 jmp Lexit69
	Lelse69:
	

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 


mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit69:
	
	leave
	ret
	Lcont68:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params70:
                        cmp rbx, r12
                        je end_copy_params70
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params70
                        end_copy_params70:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args70:
                        cmp r14, r13
                        je end_copy_stack_args70
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args70
                        end_copy_stack_args70:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode70)
                        jmp Lcont70
                        Lcode70:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 1 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_70
jl fix_case_2_70


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_70:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop70:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop70
mov qword [rsp + 8 * (2 + 1)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop70:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop70

fix_rsp70:
cmp r11, 0
je end_fix_rsp70
add rsp, 8
dec r11
jmp fix_rsp70
end_fix_rsp70:
mov qword [rsp + 16], r9
jmp end_fix70

  ;; case 3 :
;; old_n = new_n
	fix_case_3_70:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix70


;; case 2 :
;;if new_n < old_n 

fix_case_2_70:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop70:
	cmp r11, 0
	je end_shift_down_loop70
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop70
	end_shift_down_loop70:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix70:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse71
  mov rax, const_tbl + 50
	jmp Lexit71
	Lelse71:
	

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit71:
	
	leave
	ret
	Lcont70:
	
	leave
	ret
	Lcont67:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont66:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 200], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 168]
	push rax

  push 1
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode72)
		jmp Lcont72

	Lcode72:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params73:
                        cmp rbx, r12
                        je end_copy_params73
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params73
                        end_copy_params73:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args73:
                        cmp r14, r13
                        je end_copy_stack_args73
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args73
                        end_copy_stack_args73:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode73)
                        jmp Lcont73
                        
	Lcode73:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 50
	
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont73:
	
	leave
	ret
	Lcont72:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 336], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 192]
	push rax
mov rax, qword [fvar_tbl + 168]
	push rax
mov rax, qword [fvar_tbl + 16]
	push rax

  push 3
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode74)
		jmp Lcont74

	Lcode74:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params75:
                        cmp rbx, r12
                        je end_copy_params75
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params75
                        end_copy_params75:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args75:
                        cmp r14, r13
                        je end_copy_stack_args75
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args75
                        end_copy_stack_args75:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode75)
                        jmp Lcont75
                        
	Lcode75:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse76
  
mov rax, const_tbl + 67
	
 push rax 

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit76
	Lelse76:
	mov rax, const_tbl + 2
	
	Lexit76:
	
	leave
	ret
	Lcont75:
	
	leave
	ret
	Lcont74:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 344], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 16]
	push rax
mov rax, qword [fvar_tbl + 8]
	push rax

  push 2
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode77)
		jmp Lcont77

	Lcode77:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params78:
                        cmp rbx, r12
                        je end_copy_params78
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params78
                        end_copy_params78:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args78:
                        cmp r14, r13
                        je end_copy_stack_args78
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args78
                        end_copy_stack_args78:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode78)
                        jmp Lcont78
                        
	Lcode78:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	 cmp rax, SOB_FALSE_ADDRESS
	 jne Lexit79

mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 1
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
		Lexit79:
		
	leave
	ret
	Lcont78:
	
	leave
	ret
	Lcont77:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 352], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 144]
	push rax
mov rax, qword [fvar_tbl + 272]
	push rax

  push 2
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode80)
		jmp Lcont80

	Lcode80:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params81:
                        cmp rbx, r12
                        je end_copy_params81
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params81
                        end_copy_params81:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args81:
                        cmp r14, r13
                        je end_copy_stack_args81
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args81
                        end_copy_stack_args81:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode81)
                        jmp Lcont81
                        
	Lcode81:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 
mov rax, const_tbl + 50
	
 push rax 

                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params82:
                        cmp rbx, r12
                        je end_copy_params82
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params82
                        end_copy_params82:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args82:
                        cmp r14, r13
                        je end_copy_stack_args82
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args82
                        end_copy_stack_args82:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode82)
                        jmp Lcont82
                        
	Lcode82:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 67
	
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont82:
	
 push rax 

     push 3
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 7
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont81:
	
	leave
	ret
	Lcont80:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 360], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 232]
	push rax
mov rax, qword [fvar_tbl + 320]
	push rax
mov rax, qword [fvar_tbl + 176]
	push rax
mov rax, qword [fvar_tbl + 72]
	push rax
mov rax, qword [fvar_tbl + 80]
	push rax

  push 5
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode83)
		jmp Lcont83

	Lcode83:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params84:
                        cmp rbx, r12
                        je end_copy_params84
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params84
                        end_copy_params84:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args84:
                        cmp r14, r13
                        je end_copy_stack_args84
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args84
                        end_copy_stack_args84:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode84)
                        jmp Lcont84
                        
	Lcode84:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params85:
                        cmp rbx, r12
                        je end_copy_params85
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params85
                        end_copy_params85:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args85:
                        cmp r14, r13
                        je end_copy_stack_args85
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args85
                        end_copy_stack_args85:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode85)
                        jmp Lcont85
                        
	Lcode85:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 32
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 3
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params86:
                        cmp rbx, r12
                        je end_copy_params86
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params86
                        end_copy_params86:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args86:
                        cmp r14, r13
                        je end_copy_stack_args86
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args86
                        end_copy_stack_args86:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode86)
                        jmp Lcont86
                        
	Lcode86:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 50
	push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 2] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse87
  mov rax, qword [rbp + 8 * (4 + 1)]
	 jmp Lexit87
	Lelse87:
	

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 2] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 2] 
	mov rax, qword [rax + 8 *4]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, const_tbl + 67
	push rax
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 2] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit87:
	
	leave
	ret
	Lcont86:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	
mov rax, const_tbl + 1
	
 push rax 

mov rax, const_tbl + 67
	push rax

mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * (4 + 0)]
	 
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont85:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont84:
	
	leave
	ret
	Lcont83:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 368], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 112]
	push rax
mov rax, qword [fvar_tbl + 224]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 136]
	push rax
mov rax, qword [fvar_tbl + 48]
	push rax
mov rax, qword [fvar_tbl + 40]
	push rax
mov rax, qword [fvar_tbl + 24]
	push rax
mov rax, qword [fvar_tbl + 8]
	push rax
mov rax, qword [fvar_tbl + 16]
	push rax
mov rax, qword [fvar_tbl + 368]
	push rax
mov rax, qword [fvar_tbl + 168]
	push rax

  push 11
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode88)
		jmp Lcont88

	Lcode88:
	push rbp
	mov rbp, rsp
	
mov rax, const_tbl + 95
	
 push rax 

     push 1
		 
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params89:
                        cmp rbx, r12
                        je end_copy_params89
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params89
                        end_copy_params89:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args89:
                        cmp r14, r13
                        je end_copy_stack_args89
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args89
                        end_copy_stack_args89:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode89)
                        jmp Lcont89
                        
	Lcode89:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params90:
                        cmp rbx, r12
                        je end_copy_params90
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params90
                        end_copy_params90:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args90:
                        cmp r14, r13
                        je end_copy_stack_args90
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args90
                        end_copy_stack_args90:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode90)
                        jmp Lcont90
                        
	Lcode90:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse91
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *2]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit91
	Lelse91:
	mov rax, const_tbl + 2
	
	Lexit91:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse101
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit101
	Lelse101:
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse92
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *3]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit92
	Lelse92:
	mov rax, const_tbl + 2
	
	Lexit92:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse100
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit100
	Lelse100:
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *5]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse93
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *5]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit93
	Lelse93:
	mov rax, const_tbl + 2
	
	Lexit93:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse99
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *10]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *10]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *0]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit99
	Lelse99:
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *4]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse94
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *4]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit94
	Lelse94:
	mov rax, const_tbl + 2
	
	Lexit94:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse98
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *8]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *8]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax

  push 2
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse95
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *9]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *9]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit95
	Lelse95:
	mov rax, const_tbl + 2
	
	Lexit95:
	jmp Lexit98
	Lelse98:
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *6]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse96
  
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *6]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  jmp Lexit96
	Lelse96:
	mov rax, const_tbl + 2
	
	Lexit96:
	
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse97
  

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

mov rax, qword [rbp + 8 * (4 + 0)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit97
	Lelse97:
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 1] 
	mov rax, qword [rax + 8 *7]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit97:
	
	Lexit98:
	
	Lexit99:
	
	Lexit100:
	
	Lexit101:
	
	leave
	ret
	Lcont90:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	mov rax, qword [rax]
	
	leave
	ret
	Lcont89:
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 5
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	leave
	ret
	Lcont88:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 376], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, qword [fvar_tbl + 96]
	push rax
mov rax, qword [fvar_tbl + 216]
	push rax
mov rax, qword [fvar_tbl + 32]
	push rax

  push 3
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode102)
		jmp Lcont102

	Lcode102:
	push rbp
	mov rbp, rsp
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 24
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 2
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params103:
                        cmp rbx, r12
                        je end_copy_params103
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params103
                        end_copy_params103:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args103:
                        cmp r14, r13
                        je end_copy_stack_args103
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args103
                        end_copy_stack_args103:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode103)
                        jmp Lcont103
                        Lcode103:
mov r8, qword [rsp + 16] ;; r8 -> old n
mov r9, 2 ;; -> r9 -> new n
cmp r8, r9
je fix_case_3_103
jl fix_case_2_103


;; case 1 :
;;if new_n > old_n
;; make args be a improper list
	fix_case_1_103:
	;; diff = new_n - old_n
	;; acc = SOB_NIL_ADDRESS
	;; while counter <= diff
	;; 		acc = make_pair(last_element, acc)
	;; 		last_element = acc
	;; 		counter ++
	;; counter = 0
	;; while counter <= diff
	;; 		last_element = null
	;; n = old_n
	
mov rbx, r8
inc rbx
sub rbx, r9 ;; rbx -> diff
mov rax, rbx ;; rax -> save diff
mov rdx, SOB_NIL_ADDRESS ;; rdx -> list
make_pair_loop103:
mov rcx , r9
add rcx , rbx
inc rcx
mov r14, qword [rsp + 8*(rcx)] ;; r14 -> last argument
MAKE_PAIR(r15, r14, rdx) ;; r15 -> pair(last_element, acc)
mov rdx, r15 ;; rdx -> list
dec rbx
jnz make_pair_loop103
mov qword [rsp + 8 * (2 + 2)], rdx ;; put the list in the stack
mov r10, r9
add r10, 3 ;; r10 -> the size of new stack -1
mov r11, r8
add r11, 3 ;; r11 -> the size of old stack -1
shift_up_loop103:
dec r11
dec r10
mov r12, qword [rsp+8*r10]
mov qword [rsp+8*r11], r12
jnz shift_up_loop103

fix_rsp103:
cmp r11, 0
je end_fix_rsp103
add rsp, 8
dec r11
jmp fix_rsp103
end_fix_rsp103:
mov qword [rsp + 16], r9
jmp end_fix103

  ;; case 3 :
;; old_n = new_n
	fix_case_3_103:
	mov r10, qword [rsp + 8*(2+r8)] ;; r10 -> last arg
	MAKE_PAIR(r11, r10, SOB_NIL_ADDRESS) ;;-> r11 -> pointer to pair
	mov qword [rsp + 8*(2+r8)], r11 ;;  last arg become pair
	jmp end_fix103


;; case 2 :
;;if new_n < old_n 

fix_case_2_103:
	sub rsp, 8
	mov r10, r9
	add r10, 3 ;; r10 -> new stack size
	mov r11, r8 
	add r11, 3 ;; r11 -> old stack size
	mov r12, 0 ;; r12 -> counter
	shift_down_loop103:
	cmp r11, 0
	je end_shift_down_loop103
	mov r13, qword [rsp + 8*(1 + r12)]
	mov qword [rsp + 8*r12], r13
	dec r11
	inc r12
	jmp shift_down_loop103
	end_shift_down_loop103:
	mov qword [rsp + 16] , r9 ;; n = n + 1
	mov qword [rsp + 8*(r10-1)] , SOB_NIL_ADDRESS 

end_fix103:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse104
  
mov rax, const_tbl + 84
	
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *2]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit104
	Lelse104:
	

mov rax, qword [rbp + 8 * (4 + 1)]
	 push rax

  push 1
  mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *1]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 0)]
	 
 push rax 

     push 2
		 mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *2]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		
	Lexit104:
	
	leave
	ret
	Lcont103:
	
	leave
	ret
	Lcont102:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [fvar_tbl + 96], rax
	mov rax, SOB_VOID_ADDRESS
	
	call write_sob_if_not_void


mov rax, const_tbl + 95
	push rax
mov rax, const_tbl + 95
	push rax

  push 2
  MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, Lcode105)
		jmp Lcont105

	Lcode105:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * (4 + 0)]
	 
	MALLOC rbx, 8
	mov [rbx], rax
	mov rax, rbx
	
	mov qword [rbp + 8 * (4 + 0)], rax
	mov rax, SOB_VOID_ADDRESS
	
                      ;; CREATE EXT_ENV
                        MALLOC r8, 16
                        mov qword r9, [rbp+16] ;; r9 -> current env
                        mov r12, 1
                        mov r13, qword [rbp+24] ;; r13-> n 
                        mov rbx, 0 ; -> counter i
                        mov rcx, 1 ; -> counter j
                        copy_params106:
                        cmp rbx, r12
                        je end_copy_params106
                        mov r10, qword [r9 + 8*rbx] ; r10 -> curr_env[i]
                        mov qword [r8 + 8*rcx], r10 ;; ext_env[j] = curr_env[i]
                        inc rbx
                        inc rcx
                        jmp copy_params106
                        end_copy_params106:
                        mov rdx, r13
                        shl rdx, 3
                        ;; ALLOCATE CLOSURE OBJECT
                        MALLOC r15, rdx ;; malloc 8*n
                        mov r14, 0 ;; r14 -> counter of args in new env
                        copy_stack_args106:
                        cmp r14, r13
                        je end_copy_stack_args106
                        mov rbx, qword [rbp + 8*(4+r14)] ;; rbx = param_i
                        mov qword [r15 + 8*r14] , rbx;; ext_env[0][i]
                        inc r14
                        jmp copy_stack_args106
                        end_copy_stack_args106:
                        mov qword [r8], r15 ;; ext_env[0] = new_env
                        ;; MAKE_CLOSURE
                        MAKE_CLOSURE(rax,r8, Lcode106)
                        jmp Lcont106
                        
	Lcode106:
	push rbp
	mov rbp, rsp
	
mov rax, qword [rbp + 8 * 2]
	mov rax, qword [rax + 8 * 0] 
	mov rax, qword [rax + 8 *0]
	
	mov rax, qword [rax]
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	leave
	ret
	Lcont106:
	
	push rax
	mov rax, qword [rbp + 8 * (4 + 0)]
	 
	pop qword [rax] 
	mov rax, SOB_VOID_ADDRESS
	

  push 0
  mov rax, qword [fvar_tbl + 384]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	mov qword [rbp + 8 * (4 + 1)], rax
	mov rax, SOB_VOID_ADDRESS
	
mov rax, const_tbl + 86
	push rax
mov rax, const_tbl + 4
	push rax

  push 2
  mov rax, qword [rbp + 8 * (4 + 0)]
	 
	mov rax, qword [rax]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
  cmp rax, SOB_FALSE_ADDRESS
	je Lelse107
  


mov rax, const_tbl + 1
	push rax
mov rax, const_tbl + 86
	push rax

  push 2
  mov rax, qword [fvar_tbl + 232]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  push rax
mov rax, const_tbl + 86
	push rax

  push 2
  mov rax, qword [fvar_tbl + 232]
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
 push rax 
mov rax, qword [rbp + 8 * (4 + 1)]
	 
 push rax 

     push 2
		 mov rax, qword [fvar_tbl + 288]
	
		push qword [rax + 1]
		push qword [rbp + 8]
		push qword [rbp]
		mov r8, qword [rbp + 24]
		add r8, 4
		shl r8, 3
		SHIFT_FRAME 6
		add rsp, r8
		pop rbp
		jmp qword [rax  + 9]
		jmp Lexit107
	Lelse107:
	mov rax, const_tbl + 0
	
	Lexit107:
	
	leave
	ret
	Lcont105:
	
  push qword[rax + 1]
  call qword[rax + 9]
  add rsp, 8 ;;pop env
  pop rbx
  lea rsp , [rsp + 8*rbx]
  
	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret


apply:
       push rbp
       mov rbp, rsp 
       
  mov r9, qword [rbp + 3*8] ;; r9 -> number of arguments include proc and list
  mov r10 , qword [rbp+8*(r9+3)] ;; pointer to list

  mov r12, 0 ;;count size of list
  push_args_of_list:
  cmp r10, SOB_NIL_ADDRESS
  je end_push_args_of_list
  CAR r11, r10 ;;r11 contains car of list
  CDR r10, r10 ;;r10 contains cdr of list
  push r11
  inc r12
  jmp push_args_of_list 
  end_push_args_of_list:

  mov r15, r12 ;;r15 contains size of list

  mov r8, 0
  dec r12
  swap_args:
  cmp r12, r8
  jl end_swap
  mov r13, qword [rsp+8*r8] ;;down element of list
  mov r14, qword [rsp+8*r12] ;;top element of list
  mov qword [rsp+8*r8], r14 
  mov qword [rsp+8*r12], r13
  inc r8
  dec r12
  jmp swap_args
  end_swap:

  dec r9 
  dec r9
  mov r10, r9
  dec r9 ;;r9 contains number of rest of arguments - 1
   
  push_rest_args:
  cmp r9, 0
  jl end_push_rest_args
  push qword [rbp+8*(r9+5)]
  dec r9
  jmp push_rest_args
  end_push_rest_args:

  
  add r15, r10 ;;r15 contains all the arguments
  push r15 
  mov r14, r15
  mov r15, qword [rbp+32] ;;f
  CDR rdx, r15 ;;code of f
  CAR r15, r15 ;;env
  push r15
  mov r15, qword [rbp+8] ;;ret add
  push r15
  push qword [rbp]

  mov r11, r10 ;; size of rest arguments
  add r10, 6 ;; size of old frame
  mov rax, r10
  dec r10 
  add r14, 4 ;; size of new frame 
  dec r14
  fix_stack:
  cmp r14, 0
  label11111111111:
  jl end_fix_stack
  label2:
  mov rbx, qword [rbp+8*r10] ;;top elem of old
  label3:
  mov rcx, qword [rsp+8*r14] ;;top elem of new
  label4:
  mov qword [rbp+8*r10], rcx
  dec r14
  dec r10
  jmp fix_stack
  end_fix_stack:
  shl rax, 3
  add rsp, rax
  pop rbp 
  jmp rdx
  
         pop rbp
         ret
car:
       push rbp
       mov rbp, rsp 
       
    mov r8, PVAR(0) 
    mov rax , qword [r8 + 1]
         pop rbp
         ret
cdr:
       push rbp
       mov rbp, rsp 
       
    mov r8, PVAR(0) 
    mov rax , qword [r8 + 9]
         pop rbp
         ret
cons:
       push rbp
       mov rbp, rsp 
       
      mov r8, PVAR(0)
      mov r9, PVAR(1)
      MAKE_PAIR(rax, r8, r9)
  
         pop rbp
         ret
setcar:
       push rbp
       mov rbp, rsp 
       
  mov r8, PVAR(0)
  mov r9, PVAR(1)
  mov rax, r8
  mov qword [rax + 1], r9
  mov rax, SOB_VOID_ADDRESS
  
         pop rbp
         ret
setcdr:
       push rbp
       mov rbp, rsp 
       
  mov r8, PVAR(0)
  mov r9, PVAR(1)
  mov rax, r8
  mov qword [rax + 9], r9
  mov rax, SOB_VOID_ADDRESS
  
         pop rbp
         ret

